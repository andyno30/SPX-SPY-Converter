const proBackendURL = "https://spx-spy-converter-pro.onrender.com/get_live_price_pro"; // Updated Render backend

let prices = {};
let lastPrices = {}; // Stores last known valid prices
let ratios = {};

// Mapping to convert option values to normalized ticker symbols
const tickerMapping = {
    "^SPX": "SPX",
    "SPY": "SPY",
    "ES=F": "ES",
    "NQ=F": "NQ",
    "QQQ": "QQQ",
    "^NDX": "NDX"
};

// Define valid conversion pairs based on normalized ticker symbols
const validConversions = {
    "SPX": ["SPY"],
    "SPY": ["SPX"],
    "ES": ["SPY", "SPX"],
    "NQ": ["QQQ"],
    "QQQ": ["NQ", "NDX"],
    "NDX": ["QQQ"]
};

function updateProRatios() {
    document.getElementById("conversionDate").textContent = "Loading...";

    fetch(proBackendURL)
    .then(response => {
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        console.log("Received data:", data);

        if (!data || !data.Prices) {
            throw new Error("Invalid data format received from backend.");
        }

        // Update prices from the backend JSON (which is under "Prices")
        prices = data.Prices;

        // Update last known valid prices
        Object.keys(prices).forEach(ticker => {
            if (prices[ticker] !== null && prices[ticker] !== undefined) {
                lastPrices[ticker] = prices[ticker];
            }
        });

        // Set ratios directly from backend data
        ratios = {
            "SPX/SPY": data["SPX/SPY Ratio"],
            "ES/SPY": data["ES/SPY Ratio"],
            "NQ/QQQ": data["NQ/QQQ Ratio"],
            "NDX/QQQ": data["NDX/QQQ Ratio"],
            "ES/SPX": data["ES/SPX Ratio"]
        };

        document.getElementById("conversionDate").textContent = data.Datetime || "Unknown";

        // Update dropdown options based on the selected "From" ticker
        updateDropdownOptions();
    })
    .catch(error => {
        console.error('Error fetching premium data:', error);
        document.getElementById("conversionDate").textContent = "Failed to load data. Please try again later.";
    });
}

// Function to update dropdown options based on selected "From" ticker
function updateDropdownOptions() {
    const fromDropdown = document.getElementById("from-ticker");
    const toDropdown = document.getElementById("to-ticker");

    // Reset 'to' dropdown
    toDropdown.innerHTML = '<option value="">To</option>';

    const fromValueRaw = fromDropdown.value;
    // Normalize the selected ticker (if available)
    const fromValue = tickerMapping[fromValueRaw];
    
    if (fromValue && validConversions[fromValue]) {
        validConversions[fromValue].forEach(normalizedTicker => {
            // Find the corresponding raw ticker from our mapping
            // In this simple case, assume raw value is the same as normalized for SPX and SPY,
            // but for others you might need a reverse mapping if they differ.
            // We'll assume:
            // "ES" corresponds to "ES=F", "NQ" to "NQ=F", and "NDX" to "^NDX".
            let rawTicker = normalizedTicker;
            if (normalizedTicker === "ES") rawTicker = "ES=F";
            if (normalizedTicker === "NQ") rawTicker = "NQ=F";
            if (normalizedTicker === "NDX") rawTicker = "^NDX";
            
            const option = document.createElement("option");
            option.value = rawTicker;
            option.textContent = normalizedTicker;
            toDropdown.appendChild(option);
        });
    }
}

// Event listener: update 'to' dropdown when 'from' changes
document.getElementById("from-ticker").addEventListener("change", updateDropdownOptions);

// Function to update displayed ratios on the UI
function updateRatioDisplay() {
    // Define mapping of ratio keys to element IDs (use normalized ticker pairs)
    const ratioMapping = {
        "SPX/SPY": "ratio-spx-spy",
        "ES/SPY": "ratio-es-spy",
        "NQ/QQQ": "ratio-nq-qqq",
        "NDX/QQQ": "ratio-ndx-qqq",
        "ES/SPX": "ratio-es-spx"
    };

    Object.keys(ratioMapping).forEach(key => {
        const element = document.getElementById(ratioMapping[key]);
        if (element) {
            element.textContent = ratios[key] !== undefined && ratios[key] !== null 
                ? ratios[key].toFixed(8)
                : "N/A";
        }
    });
}

// Conversion function based on ratios
function convertPremium() {
    const fromTickerRaw = document.getElementById("from-ticker").value;
    const toTickerRaw = document.getElementById("to-ticker").value;
    const value = parseFloat(document.getElementById("convert-input").value);

    if (!fromTickerRaw || !toTickerRaw || isNaN(value)) {
        document.getElementById("convert-output").textContent = "Please select tickers and enter a value.";
        return;
    }

    // Normalize tickers
    const fromTicker = tickerMapping[fromTickerRaw] || fromTickerRaw;
    const toTicker = tickerMapping[toTickerRaw] || toTickerRaw;
    
    const ratioKey = `${fromTicker}/${toTicker}`;
    const inverseRatioKey = `${toTicker}/${fromTicker}`;
    let convertedValue;

    if (ratios[ratioKey] !== undefined && ratios[ratioKey] !== null) {
        convertedValue = value * ratios[ratioKey];
    } else if (ratios[inverseRatioKey] !== undefined && ratios[inverseRatioKey] !== null) {
        convertedValue = value / ratios[inverseRatioKey];
    } else {
        document.getElementById("convert-output").textContent = "Invalid conversion.";
        return;
    }

    document.getElementById("convert-output").textContent = `${toTicker}: ${convertedValue.toFixed(8)}`;
}

// Fetch ratios every 60 seconds
setInterval(updateProRatios, 60000);
updateProRatios();

// Update displayed ratios every second
setInterval(updateRatioDisplay, 1000);
